#include <iostream>
#include "algo.h"
#include <vector>
#include <tuple>
using namespace std;
using namespace Eigen;

void GradPasOptimal (const MatrixXd A, const VectorXd b, const VectorXd x0, const double epsilon, const int kmax, VectorXd & x)
{
  //Initialisation
  int k=0;
  VectorXd r(b.size()); r=b-A*x0;
  VectorXd z(b.size());
  double alpha;
  x=x0;
  //Boucle
  while((r.norm()>epsilon) && (k<=kmax))
    {
      z =A*r;
      alpha = r.dot(r) / z.dot(r);
      x = x + alpha*r;
      r = r - alpha*z;
      k+=1;
    }

  if (k>kmax)
    {
      cout<<"Tolérance non atteinte: "<<endl;
    }
  
}

void ResMin (const MatrixXd A,const VectorXd b, const VectorXd x0,const double epsilon,const int kmax, VectorXd & x)

{
  //Initialisation
  int k=0;
  VectorXd r(b.size()); r=b-A*x0;
  VectorXd z(b.size());
  double alpha;
  x=x0;
  //Boucle
  while ((r.norm()>epsilon) && (k<=kmax))
    {
      z = A*r;
      alpha = r.dot(z) / z.dot(z);
      x = x + alpha*r;
      r = r - alpha*z;
      k+=1;
    }

  if (k>kmax)
    {
      cout<<"Tolérance non atteinte: "<<endl;
      }
}


MatrixXd ArnoldiH(const Eigen::MatrixXd A, Eigen::VectorXd & v)
{
  int m;
  m=v.size();
  vector <Eigen::VectorXd> Vm(m);
  MatrixXd Hm(m,m);
  vector<Eigen::VectorXd> w(m); 
  Vm[0]=v/v.norm();

  for (int j=0; j<m;j++)
    {
      w[j]=A*Vm[j];
      for (int i=0;i<j;i++)
	{
	  Hm(i,j)=w[j].dot(Vm[i]);
	  w[j]=w[j]-Hm(i,j)*Vm[i];
	}
      Hm(j+1,j)=w[j].norm();
      if (Hm(j+1,j)==0.)
	break;
      Vm[j+1]=w[j]/Hm(j+1,j);
	
    }    
  return Hm;
}

vector<Eigen::VectorXd> ArnoldiV(const Eigen::MatrixXd A, Eigen::VectorXd & v)
{
  int m;
  m=v.size();
  vector< Eigen::VectorXd> Vm(m);
  MatrixXd Hm(m,m);
  vector<Eigen::VectorXd> w(m); 
  Vm[0]=v/v.norm();

  for (int j=0; j<m;j++)
    {
      w[j]=A*Vm[j];
      for (int i=0;i<j;i++)
	{
	  Hm(i,j)=w[j].dot(Vm[i]);
	  w[j]=w[j]-Hm(i,j)*Vm[i];
	}
      Hm(j+1,j)=w[j].norm();
      if (Hm(j+1,j)==0.)
	break;
      Vm[j+1]=w[j]/Hm(j+1,j);
	
    }    
  return Vm;
}





// void GMRes(const Eigen::MatrixXd A, const Eigen::VectorXd b, const Eigen::VectorXd x0, const double epsilon, const int kmax, Eigen::VectorXd & x);

// //Initialisation
// int k=0;
// VectorXd r(b.size()); r=b-A*x0;
// VectorXd z(b.size());


